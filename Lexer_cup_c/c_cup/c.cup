import java.io.*;
import java_cup.runtime.*;
import java.util.*;

 

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at "+cur_token);
    }
   

    public static void main(String args[]) {
	try {
	    CLexer lexer = new CLexer(new FileReader(args[0]));
	    // start parsing
	    Parser p = new Parser(lexer);
	    System.out.println("Parser runs: ");
            p.parse();
	    System.out.println("Parsing finished!");
	} catch (Exception e) {
	    e.printStackTrace();
	} 
    }
:};


terminal
    DOT,
    EQ,
    AND,
    NULL_LITERAL,
    ERROR,
    ID,
    CONSTANT, 
    STRING, 
    SIZEOF, 
    PTR_OP, 
    PLUSPLUS, 
    MINUSMINUS, 
    LSHIFT, 
    RSHIFT, 
    LTEQ, 
    GTEQ,
    EQEQ, 
    NOTEQ, 
    ANDAND, 
    OROR, 
    MULTEQ,
    DIVEQ, 
    MODEQ, 
    PLUSEQ,
    MINUSEQ, 
    LSHIFTEQ,
    RSHIFTEQ,
    ANDEQ,
    XOREQ,
    OREQ,
    TYPE_NAME,
    TYPEDEF, 
    EXTERN, 
    STATIC, 
    AUTO, 
    REGISTER,
    CHAR_TYPE, 
    SHORT_TYPE, 
    INT_TYPE, 
    LONG_TYPE, 
    SIGNED, 
    UNSIGNED, 
    FLOAT_TYPE, 
    DOUBLE_TYPE, 
    CONST, 
    VOLATILE, 
    VOID, 
    STRUCT, 
    ENUM, 
    ELLIPSIS,
    CASE, 
    DEFAULT, 
    IF, 
    ELSE, 
    SWITCH, 
    WHILE, 
    DO, 
    FOR, 
    GOTO, 
    CONTINUE, 
    BREAK, 
    RETURN,
    SEMICOLON, 
    LBRACE, 
    RBRACE, 
    COMMA, 
    COLON, 
    LPAREN, 
    RPAREN, 
    LBRACK, 
    RBRACK, 
    POINT_TYPE,
    ADRESS, 
    NOT, 
    COMP, 
    MINUS, 
    PLUS, 
    MULT, 
    DIV, 
    MOD, 
    LT, 
    GT, 
    XOR, 
    OR, 
    QUESTION
    ;

    
non terminal program;
non terminal var_declaration;
non terminal function_declaration;
non terminal type_var; 
non terminal type_specifier;
non terminal type_sign;  
non terminal type_var_sign_unsign;              /*variabili a cui posso far precedere SIGNED | UNSIGNED */
non terminal param_list;
non terminal statement;
non terminal expression;
non terminal operator;
non terminal assignment_operator;
non terminal rpar_generic;
non terminal lpar_generic;
non terminal boolean_operator;
non terminal loop_statement;
non terminal for_loop_statement;
non terminal assignment_expression;
non terminal cond_expression;
non terminal statement_list;
non terminal cond_statement;
non terminal call_function;
non terminal param_list_call;
non terminal list_number;
non terminal array_statement;
non terminal array_declaration;

precedence left OROR;
precedence left ANDAND;
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left EQEQ ,NOTEQ,NOT;
precedence left LT ,GT, LTEQ ,GTEQ;
precedence left MINUS, PLUS;
precedence left MULT, DIV,MOD;


 start with program;
 
 
program             
                        ::= 
                        function_declaration program          {: System.out.println("function_declaration"); :}           /* dichiarazione funzioni */
                        |statement program
                        |
                        ;
                        
                        


                
var_declaration         
                        ::=
                        type_var ID:id 
                        | type_var ID:id assignment_operator expression
                        ;

list_number
                        ::=
                        CONSTANT COMMA list_number
                        |CONSTANT
                        ;
                        
array_statement
                        ::=
                        LBRACE RBRACE
                        |LBRACE list_number RBRACE
                        
                        ;
                        

array_declaration       
                        ::=
                        type_var ID:id LBRACK CONSTANT RBRACK
                        |type_var ID:id LBRACK CONSTANT RBRACK EQ array_statement
                        
                        ;
                    
type_var_sign_unsign    
                        ::=  
                        type_sign CHAR_TYPE:type
                        | type_sign SHORT_TYPE:type
                        | type_sign INT_TYPE:type
                        | type_sign LONG_TYPE:type
                        ;
                        
                      
                        
type_var               
                        ::=
                        FLOAT_TYPE:type
                        | DOUBLE_TYPE:type
                        | type_var_sign_unsign:type        /*variabili a cui posso far precedere SIGNED | UNSIGNED */
                        ;              
                    
type_sign             
                        ::=
                        SIGNED
                        |UNSIGNED
                        |
                        ;            

call_function
                        ::=
                        ID:id LPAREN param_list_call RPAREN
                        ;
                    
function_declaration    
                        ::=  
                        type_var ID:id LPAREN param_list  RPAREN cond_statement
                        | type_specifier ID:id LPAREN param_list RPAREN cond_statement
                        ;



type_specifier
                        ::=
                        VOID:type
                        ;


param_list_call
                        ::=
                        ID:id COMMA param_list_call
                        |ID:id
                        |call_function COMMA param_list_call
                        |call_function
                        |
                        ;
            
param_list
                        ::=
                        type_var ID:id COMMA param_list
                        |type_var ID:id
                        |
                        ;
                        
statement_list 
                        ::=
                        statement statement_list
                        |statement
                        ;

statement
                        ::=
                        var_declaration SEMICOLON
                        |expression SEMICOLON
                        |assignment_expression SEMICOLON
                        |cond_expression
                        |call_function SEMICOLON
                        |array_declaration SEMICOLON
                        |SEMICOLON
                        ;
                    
loop_statement
                        ::=
                        expression
                        |assignment_expression
                        |cond_expression
                        ;
for_loop_statement
                        ::=
                        loop_statement
                        |
                        ;



assignment_expression
                        ::=
                        ID:e1 assignment_operator expression:e2
                        |ID:e1 LBRACK CONSTANT RBRACK assignment_operator expression:e2
                        ;
    

cond_expression
                        ::=
                        IF LPAREN loop_statement RPAREN cond_statement
                        |WHILE LPAREN loop_statement RPAREN cond_statement
                        |FOR LPAREN for_loop_statement SEMICOLON for_loop_statement SEMICOLON for_loop_statement RPAREN cond_statement
                        ;
                        
cond_statement
                        ::=
                        LBRACE statement_list RBRACE
                        |LBRACE RBRACE
                        |statement
                        ;
                        
expression 
                        ::=
                        expression:e1 operator:op expression:e2 
                        |expression:e1 boolean_operator:op expression:e2
                        |lpar_generic expression rpar_generic
                        |ID 
                        |CONSTANT
                        
                        ;
/*                        
expression              
                        ::=     
                        expression:e1 operator:op expression:e2 SEMICOLON
                        |expression:e1 operator:op expression:e2
                        
                        |expression:e1 boolean_operator:op expression:e2 
                        |expression:e1 boolean_operator:op expression:e2 SEMICOLON
                        |ID:e1 assignment_operator expression:e2 SEMICOLON
                        |ID:e1 assignment_operator expression:e2
                        |lpar_generic expression rpar_generic
                        |IF LPAREN loop_statement RPAREN LBRACE statement RBRACE 
                        |WHILE LPAREN loop_statement RPAREN LBRACE statement RBRACE 
                        |FOR LPAREN loop_statement  RPAREN LBRACE statement RBRACE
                        |ID 
                        |CONSTANT
                        ;                        
  */                      

lpar_generic 
                        ::=
                        LPAREN
                        |LBRACK
                        ;
                        
                        
rpar_generic
                        ::=
                        RPAREN
                        |RBRACK
                        ;
                       
                       
                        
operator
                        ::=
                        MULT
                        |DIV
                        |MINUS
                        |XOR
                        |PLUS
                        |AND
                        |OR
                        |MOD
                        ;
                        
                        
                        

                        
                        

assignment_operator
                        ::= 
                        EQ
                        |MULTEQ     
                        |DIVEQ     
                        |MODEQ     
                        |PLUSEQ     
                        |MINUSEQ     
                        |LSHIFTEQ    
                        |RSHIFTEQ   
                        |ANDEQ     
                        |XOREQ     
                        |OREQ      
                        ;
                        
                        
boolean_operator
                        ::= 
                        EQEQ
                        |ANDAND
                        |OROR
                        |LT
                        |GT
                        |LTEQ
                        |GTEQ
                        |NOT
                        |NOTEQ
                        ;

      
                        