   
non terminal translation_unit;
non terminal primary_expression;
non terminal postfix_expression;
non terminal expression;
non terminal argument_expression_list;
non terminal assignment_expression;
non terminal unary_expression;
non terminal unary_operator;
non terminal type_name;
non terminal  cast_expression;
non terminal  multiplicative_expression;
non terminal  additive_expression;
non terminal  relational_expression;
non terminal  shift_expression;
non terminal  equality_expression;
non terminal  and_expression;
non terminal  exclusive_or_expression;
non terminal  inclusive_or_expression;
non terminal  logical_and_expression;
non terminal  logical_or_expression;
non terminal  conditional_expression;
non terminal  constant_expression;
non terminal  declaration;
non terminal  declaration_specifiers;
non terminal  init_declarator_list;
non terminal  storage_class_specifier;
non terminal  type_specifier;
non terminal  type_qualifier;
non terminal  init_declarator;
non terminal  declarator;
non terminal  struct_or_union_specifier;
non terminal  struct_declaration_list;
non terminal struct_or_union;
non terminal  struct_declaration;
non terminal  initializer;
non terminal  specifier_qualifier_list;
non terminal  struct_declarator_list;
non terminal  struct_declarator;
non terminal  enum_specifier;
non terminal  enumerator_list;
non terminal  enumerator;
non terminal  pointer;
non terminal  direct_declarator;
non terminal  parameter_type_list;
non terminal  identifier_list;
non terminal  type_qualifier_list;
non terminal  parameter_declaration;
non terminal  abstract_declarator;
non terminal  direct_abstract_declarator;
non terminal  initializer_list;
non terminal  statement;
non terminal  labeled_statement;
non terminal  compound_statement;
non terminal  selection_statement;
non terminal  iteration_statement;
non terminal  jump_statement;
non terminal  statement_list;
non terminal  expression_statement;
non terminal  external_declaration;
non terminal  function_definition;
non terminal  declaration_list;
non terminal  assignment_operator;
non terminal  parameter_list;


precedence nonassoc ELSE;



start with translation_unit;

primary_expression ::= ID:ident
		   | CONSTANT:constant 
		   | STRING:stringliteral  
		   | LPAREN expression:e RPAREN 
		   ;

postfix_expression ::= primary_expression:pe 
		   | postfix_expression:pe LBRACK expression:index RBRACK 
		   | postfix_expression:pe LPAREN RPAREN 
		   | postfix_expression:pe LPAREN expression:e RPAREN 
		   | postfix_expression:pe POINT_TYPE ID:id
		   | postfix_expression:pe PTR_OP ID:id
		   | postfix_expression:pe PLUSPLUS:op
		   | postfix_expression:pe MINUSMINUS:op
		   ;

unary_expression ::= postfix_expression:pe 
		 | PLUSPLUS:op unary_expression:ue
		 | MINUSMINUS:op unary_expression:ue
		 | unary_operator:uo cast_expression:ce
		 | SIZEOF unary_expression:ue
		 | SIZEOF LPAREN type_name:tn RPAREN
		 ;

unary_operator
	::=ADRESS
	| MULT:op
	| PLUS:op
	| MINUS:op
	| COMP
	| NOT:op
	;


cast_expression
	::=unary_expression:ue
	| LPAREN type_name:tn RPAREN cast_expression:ce
	;


multiplicative_expression ::= cast_expression:ce 
			  | multiplicative_expression:me MULT:op cast_expression:ce
			  | multiplicative_expression:me DIV:op cast_expression:ce
			  | multiplicative_expression:me MOD:op cast_expression:ce
			  ;

additive_expression ::= multiplicative_expression:me
		    | additive_expression:ae PLUS:op multiplicative_expression:me
		    | additive_expression:ae MINUS:op multiplicative_expression:me
		    ;

shift_expression ::= additive_expression:ae
		 | shift_expression:se LSHIFT additive_expression:ae
		 | shift_expression:se RSHIFT additive_expression:ae
		 ;

relational_expression ::= shift_expression:se
		      | relational_expression:re LT:op shift_expression:se
		      | relational_expression:re GT:op shift_expression:se
		      | relational_expression:re LTEQ:op shift_expression:se
		      | relational_expression:re GTEQ:op shift_expression:se
		      ;

equality_expression ::= relational_expression:re
		    | equality_expression:ee EQEQ:op relational_expression:re
		    | equality_expression:ee NOTEQ:op relational_expression:re
		    ;

and_expression ::= equality_expression:ee
	       | and_expression:ae ADRESS equality_expression:ee
	       ;

exclusive_or_expression	::= and_expression:ae
			| exclusive_or_expression:eoe XOR and_expression:ae
			;


inclusive_or_expression	::= exclusive_or_expression:eoe
			| inclusive_or_expression:ioe OR exclusive_or_expression:eoe
			;

logical_and_expression ::= inclusive_or_expression:ioe
		       | logical_and_expression:lae ANDAND:op inclusive_or_expression:ioe
		       ;

logical_or_expression ::= logical_and_expression:lae
		      | logical_or_expression:loe OROR:op logical_and_expression:lae
		      ;

conditional_expression ::= logical_or_expression:loe
		       | logical_or_expression:loe QUESTION expression:e COLON conditional_expression:ce
		       ;


assignment_expression ::= conditional_expression:ce
		      | unary_expression:ue assignment_operator:aop assignment_expression:ae
		      ;

assignment_operator
	::=EQ      
	| MULTEQ     
	| DIVEQ     
	| MODEQ     
	| PLUSEQ     
	| MINUSEQ     
	| LSHIFTEQ    
	| RSHIFTEQ   
 	| ANDEQ     
	| XOREQ     
	| OREQ      
	;

expression ::= assignment_expression:ae
	   | expression:e COMMA assignment_expression:ae
	   ;

constant_expression
	::=conditional_expression:ce
	;

declaration
	::=declaration_specifiers:ds SEMICOLON
        | declaration_specifiers:ds init_declarator_list:idl  SEMICOLON {: System.out.println("declaration"); :}
        ;

declaration_specifiers
	::=storage_class_specifier:scc 
        | storage_class_specifier:scc declaration_specifiers:ds 
	| type_specifier:ts 
	| type_specifier:ts declaration_specifiers:ds 
	| type_qualifier:tq 
	| type_qualifier:tq declaration_specifiers:ds 
	;

init_declarator_list
	::=init_declarator:id 
	| init_declarator_list:idl COMMA init_declarator:id 
	;

init_declarator
        ::=declarator:d 
	| declarator:d EQ initializer:i 
	;

initializer
	::=assignment_expression:ae
	| LBRACE initializer_list:il RBRACE
	| LBRACE initializer_list:il COMMA RBRACE 
	;

initializer_list
	::=initializer:i
	| initializer_list:il COMMA initializer:i
	;
	
	
	
storage_class_specifier
    ::=  TYPEDEF:id 
	| EXTERN:id 
	| STATIC:id 
	| AUTO:id 
	| REGISTER:id
	;

type_specifier
	::=VOID:type
	| CHAR_TYPE:type
	| SHORT_TYPE:type
	| INT_TYPE:type
	| LONG_TYPE:type
	| FLOAT_TYPE:type
	| DOUBLE_TYPE:type
	| SIGNED:type
	| UNSIGNED:type
	| struct_or_union_specifier:su
	| enum_specifier:es
	| TYPE_NAME:type
	;
	
struct_or_union_specifier
	::= STRUCT:s ID:id LBRACE struct_declaration_list:sdl RBRACE 
	|  STRUCT:s LBRACE struct_declaration_list:sdl RBRACE
	|  STRUCT:s ID:id 
	|  UNION:u ID:id LBRACE struct_declaration_list:sdl RBRACE
	|  UNION:u LBRACE struct_declaration_list:sdl RBRACE
	|  UNION:u ID:id
	;

struct_declaration_list
	::=struct_declaration:s
	| struct_declaration_list:sl struct_declaration:s
	;

struct_declaration
	::=specifier_qualifier_list:sq struct_declarator_list:sd SEMICOLON
	;

specifier_qualifier_list
	::=type_specifier:ts specifier_qualifier_list:sq 
	| type_specifier:ts
	| type_qualifier:tq specifier_qualifier_list:sq
	| type_qualifier:tq
	;

struct_declarator_list
	::=struct_declarator:s 
	| struct_declarator_list:sl COMMA struct_declarator:s 
	;

struct_declarator
	::=declarator:d 
	| COLON constant_expression:ce 
	| declarator:d COLON constant_expression:ce 
	;

enum_specifier
	::=ENUM LBRACE enumerator_list:el RBRACE 
	| ENUM ID:id LBRACE enumerator_list:el RBRACE
	| ENUM ID:id 
	;

enumerator_list
	::=enumerator:e 
	| enumerator_list:el COMMA enumerator:e 
	;

enumerator
	::=ID:id
	| ID:id EQ constant_expression:ce 
	;

type_qualifier
	::=CONST:id
	| VOLATILE:id 
	;

declarator
	::=pointer:p direct_declarator:direct 
	| direct_declarator:direct
	;

direct_declarator 
	::=ID:identifier 
	| LPAREN declarator:d RPAREN 
	| direct_declarator:dd LBRACK constant_expression:ce RBRACK 
	| direct_declarator:dd LBRACK RBRACK  
	| direct_declarator:dd LPAREN parameter_type_list:ptl RPAREN  
	| direct_declarator:dd LPAREN identifier_list:il RPAREN 
	| direct_declarator:dd LPAREN RPAREN
	;

pointer
	::=MULT:id 
	| MULT:id type_qualifier_list:tql
	| MULT:id pointer:p
	| MULT:id type_qualifier_list:tql pointer:p
	;

type_qualifier_list
	::=type_qualifier:tq 
	| type_qualifier_list:tql type_qualifier:tq
	;


parameter_type_list
	::=parameter_list:pl
	| parameter_list:pl COMMA ELLIPSIS:id
	;


parameter_list
	::=parameter_declaration:pd 
	| parameter_list:pl COMMA parameter_declaration:pd
	;

parameter_declaration
	::=declaration_specifiers:ds declarator:d
	| declaration_specifiers:ds abstract_declarator:ad 
	| declaration_specifiers:ds
	;

identifier_list
	::=ID:id 
	| identifier_list:idl COMMA ID:id 
	;

type_name
	::=specifier_qualifier_list:sl
	| specifier_qualifier_list:sl abstract_declarator:ad 
	;

abstract_declarator
	::=pointer:p
	| direct_abstract_declarator:dad
	| pointer:p direct_abstract_declarator:d
	;

direct_abstract_declarator
	::=LPAREN:id abstract_declarator:ad RPAREN 
	| LBRACK:id RBRACK 
	| LBRACK:id constant_expression:ce RBRACK 
	| direct_abstract_declarator:dad LBRACK:id RBRACK
	| direct_abstract_declarator:dad LBRACK:id constant_expression:ce RBRACK
	| LPAREN:id RPAREN
	| LPAREN:id parameter_type_list:ptl RPAREN
	| direct_abstract_declarator:dad LPAREN:id RPAREN
	| direct_abstract_declarator:dad LPAREN:id parameter_type_list:ptl RPAREN 
	;


statement
	::=labeled_statement:ls
	|  compound_statement:cs {:  :} 
	| expression_statement:es
	| selection_statement:ss 
	| iteration_statement:is 
	| jump_statement:js
	;

labeled_statement
	::=ID:id COLON statement:s
	| CASE constant_expression:ce COLON statement:s
	| DEFAULT COLON statement:s
	;

compound_statement
	::=LBRACE RBRACE 
        | LBRACE statement_list:sl RBRACE 
	| LBRACE declaration_list:dl RBRACE 
	| LBRACE declaration_list:dl statement_list:sl RBRACE 
	;

declaration_list
	::=declaration:d
	| declaration_list:dl declaration:d 
	;

statement_list
	::=statement:s
	| statement_list:sl statement:s
	;

expression_statement
	::=SEMICOLON 
	| expression:e SEMICOLON 
	;

selection_statement
	::=IF LPAREN expression:e RPAREN statement:s
	| IF LPAREN expression:e RPAREN statement:s1 ELSE statement:s2 
	| SWITCH LPAREN expression:e RPAREN statement:s
	;

iteration_statement
	::=WHILE LPAREN expression:e RPAREN statement:s 
	| DO statement:s WHILE LPAREN expression:e RPAREN SEMICOLON
	| FOR LPAREN expression_statement:es1 expression_statement:es2 RPAREN statement:s
	| FOR LPAREN expression_statement:es1 expression_statement:es2 expression:e RPAREN statement:s
	;

jump_statement
	::=GOTO ID:id SEMICOLON 
	| CONTINUE SEMICOLON
	| BREAK SEMICOLON 
	| RETURN SEMICOLON 
	| RETURN expression:e SEMICOLON 
	;

translation_unit
	::=external_declaration:ed 
	| translation_unit:tu external_declaration:ed 
	;

external_declaration
	::=function_definition:fd 
	| declaration:d
	;

function_definition
	::=declaration_specifiers:ds declarator:d declaration_list:dl  compound_statement:cs {: :}
	| declaration_specifiers:ds declarator:d   compound_statement:cs {: :} 
	| declarator:d declaration_list:dl  compound_statement:cs {:  :} 
	| declarator:d   compound_statement:cs {:  :} 
	;